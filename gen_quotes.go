//go:build ignore

// Generate quotes.go from quotes.txt and geek-quotes.txt

package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
)

const authorPre = "    - "

var header = `package main
// Generated by gen_quotes.go, DO NOT EDIT

var quoteDB = []string{
`

func genQuotes(r io.Reader, w io.Writer) error {
	s := bufio.NewScanner(r)
	var lines []string
	lnum := 0
	for s.Scan() {
		lnum++
		if strings.TrimSpace(s.Text()) == "" {
			if len(lines) > 0 {
				return fmt.Errorf("%d: no author", lnum)
			}
			lines = lines[:0]
			continue
		}

		lines = append(lines, s.Text())
		if strings.HasPrefix(s.Text(), authorPre) {
			quote := strings.Join(lines, "\n")
			fmt.Fprintf(w, "%q,\n", quote)
			lines = lines[:0]
			continue
		}
	}

	return s.Err()
}

func main() {
	matches, err := filepath.Glob("data/*.txt")
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %s\n", err)
		os.Exit(1)
	}

	out, err := os.Create("quotes.go")
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %s\n", err)
		os.Exit(1)
	}
	defer out.Close()

	fmt.Fprintf(out, header)
	for _, fileName := range matches {
		fmt.Println(fileName)
		in, err := os.Open(fileName)
		if err != nil {
			fmt.Fprintf(os.Stderr, "error: %s\n", err)
			os.Exit(1)
		}
		defer in.Close()
		if err := genQuotes(in, out); err != nil {
			fmt.Fprintf(os.Stderr, "error: %q: %s\n", fileName, err)
			os.Exit(1)
		}
	}

	fmt.Fprintf(out, "}\n")
}
